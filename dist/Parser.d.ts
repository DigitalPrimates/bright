import { IToken, Parser } from 'chevrotain';
export declare class RokuBRSParser extends Parser {
    Program: (idxInCallingRule?: number, ...args: any[]) => any;
    protected BlockStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected Statement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ArrayExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ObjectExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected Property: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ArrayElement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected PropertyName: (idxInCallingRule?: number, ...args: any[]) => any;
    protected DimStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected EmptyStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ExitStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected IfStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ElseIfStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ElseStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ForStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ForEachStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected GoToStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected LabeledStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected LibraryStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected NextStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected PrintStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ReturnStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected StopStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected WhileStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected FunctionExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected FunctionDeclaration: (idxInCallingRule?: number, ...args: any[]) => any;
    protected SubExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected SubDeclaration: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ParameterList: (idxInCallingRule?: number, ...args: any[]) => any;
    protected Parameter: (idxInCallingRule?: number, ...args: any[]) => any;
    protected TypeAnnotation: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ExpressionStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected AssignmentExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected AdditionExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected MultiplicationExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ShiftExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected RelationExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected EqualityExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected LogicExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected UnaryExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected Arguments: (idxInCallingRule?: number, ...args: any[]) => any;
    protected PostfixExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected MemberExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected MemberChunkExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected BoxMemberExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected DotMemberExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected PrimaryExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ParenthesisExpression: (idxInCallingRule?: number, ...args: any[]) => any;
    protected Literal: (idxInCallingRule?: number, ...args: any[]) => any;
    protected UnTypedIdentifier: (idxInCallingRule?: number, ...args: any[]) => any;
    protected Identifier: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ReservedWord: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ConditionalCompilationStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ConditionalConst: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ConditionalError: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ConditionalIfStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ConditionalElseIfStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected ConditionalElseStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    protected Comment: (idxInCallingRule?: number, ...args: any[]) => any;
    protected EndOfStatement: (idxInCallingRule?: number, ...args: any[]) => any;
    private cacheStatement;
    private cacheReservedWord;
    private cachePrimaryExpression;
    private cacheConditionalCompilationStatement;
    constructor(input: IToken[]);
}
export declare const parserInstance: RokuBRSParser;
export declare function parse(source: any, entryPoint?: string): {
    lexErrors: import("../node_modules/chevrotain/lib/chevrotain").ILexingError[];
    parseErrors: import("../node_modules/chevrotain/lib/chevrotain").IRecognitionException[];
    parserInstance: RokuBRSParser;
    tokens: {
        loc: {
            start: {
                column: any;
                line: any;
            };
            end: {
                column: any;
                line: any;
            };
        };
        range: any[];
        type: any;
        value: any;
    }[];
    value: any;
};
